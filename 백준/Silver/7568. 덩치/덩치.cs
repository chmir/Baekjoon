using System;
//shift + f5 = 코드 실행
class Program {
    static void Main(string[] args) {
        //bj 7568 /s5 /덩치 /231130
		//사람의 몸무게, 키를 n번 입력 받는다. 
		//2<=n<50, 10<=x,y<=200
		
		//반성할점-
		//브루트포스 알고리즘이라는 키워드에 들떠서 
		//너무 이상한 쪽으로 길게 고민한 문제 
		//생각해보자, 같은 등수끼리는 굳이 비교할 필요가 없다. 
		//그리고 n번 등수가 밀려났으면 n-1번 수도 비교할 필요가 없다. 
		//그렇다면 가장 심플하게, 모든 키와 몸무게를 구분해서 
		//랭크를 카운트하면 그만인 문제가 아닐까? 
		//문제가 2시간 동안 헤매도 답이 안나온다면 과감히 답을 보고 해석을 하자!
		
		//그런데... 10 20, 11 18, 12 19 이렇게 나오면 등수가 어캐되지? 
		//당연히 11 18이 2등이 되겠지만 뭔가 찜찜하다.. 10 20과는 등치가 같은데
		
		//변수 세팅
		int n = Int32.Parse(Console.ReadLine()); //입력 개수
		int[,] size = new int[n, 2]; //n개의 키와 몸무게
		int rank; //등수를 표현할 변수		
		//입력, s.split()에 바로 인덱스를 붙혀도 되는건 처음 알았다.
		for(int i = 0; i < n; i++){
			//공백으로 나눠 n번에 값 두개를 넣는다. 
			string s = Console.ReadLine(); //"xx yyy"
			size[i, 0] = int.Parse(s.Split()[0]); //몸무게
			size[i, 1] = int.Parse(s.Split()[1]); //키
		}		
		//연산
		for (int i = 0; i < n; i++) //i번 반복될 인덱스
		{
			rank = 1; //모든 등수는 1등부터 시작한다 
			for (int j = 0; j < n; j++) //j번 반복될 인덱스
			{
				//단순히 i와 j를 비교해서 현재 비교중인 j가 클 경우 rank++ 한다.
				//왜냐? 현재 i가 더 작은 덩치임을 나타내기에 rank++이다, 등수가 높을수록 작은거니까. 
				//어차피 i와 j가 같은 순간이 오더라도 ++될일이 없으니 예외처리 필요X
				if (size[i, 0] < size[j, 0] && size[i, 1] < size[j, 1])
				{
					rank++; //i 인덱스의 등수를 뒤로 미룬다. 
				}
				//만약 i가 그 어떤수랑 비교해도 꿀리지 않는 덩치라면 여전히 1등이라 할 수 있다.
			}
			//i인덱스의 등수를 출력한다.
			Console.Write($"{rank} "); //간격을 한칸 띔에 유의 
		}
		
	}
}